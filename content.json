{"meta":{"title":"Mark's Inn","subtitle":null,"description":null,"author":"Mr.Cai","url":"https://markcai520.github.io","root":"/"},"pages":[{"title":"关于小站","date":"2019-07-16T04:13:45.000Z","updated":"2019-07-16T09:24:59.345Z","comments":true,"path":"about/index.html","permalink":"https://markcai520.github.io/about/index.html","excerpt":"匣有剑否，转身皆是江湖 剑未佩妥，出门便已是江湖 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初离学堂，踏入“江湖”，总归是要尝过千种心酸、万般无奈。在时间无情打磨之后，你总能得到一些东西。可人真的是“分三六九等”的，有的人初入职场，不多时，便游刃有余，升职加薪，不在话下，而有的人，务必勉强地找个小工作，朝九晚六地坐着，无论过多久，都是那个样子。这是为何？其实不难解释，同样是初入江湖，人家宝剑傍身，自信沉着，你赤手空拳，卑微怯懦，如何能比？","text":"匣有剑否，转身皆是江湖 剑未佩妥，出门便已是江湖 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初离学堂，踏入“江湖”，总归是要尝过千种心酸、万般无奈。在时间无情打磨之后，你总能得到一些东西。可人真的是“分三六九等”的，有的人初入职场，不多时，便游刃有余，升职加薪，不在话下，而有的人，务必勉强地找个小工作，朝九晚六地坐着，无论过多久，都是那个样子。这是为何？其实不难解释，同样是初入江湖，人家宝剑傍身，自信沉着，你赤手空拳，卑微怯懦，如何能比？ 愿你有利剑藏匣 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;职场是残酷的江湖，当然，所谓祸福相依，这里同样是你发家致富，走上人生巅峰的试炼场，只希望你心中有谱，手中有剑，所过之处，披荆斩棘。 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;咳咳，自从学了计算机，书读得相对以前少了些，虽说受金庸老先生影响，心里对江湖依然是十分向往，但多少是有些变了质，不似从前一般纯粹了，还是好好说人话吧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博主目前是一个即将本科毕业的计算机专业小白，嘿嘿，真的，说起小白，我可是专业的哟~~，在这里想对和我一样即将毕业的同学，或是学弟学妹们说，当然，不打算从事计算机相关职业的出门左转(你要是开心，留下来也可以，哈哈哈)。无论你是打算考研，还是毕业直接进入职场，有几项技能都是你必须掌握的：操作系统、数据结构、算法(远不止这些，但这三个是我目前认为，相对来说最重要的三块，个人观点，欢迎来辩)。这里就不展开话题继续深聊了，有空再专门写两篇博客聊聊这三块怎么学吧。 联系博主 QQ：250057558 Email:18468126183@163.com 微信： 扫描下方二维码 &lt;图片给你搞大点，扫起来就方便啦&gt;"},{"title":"books","date":"2019-07-16T04:34:22.000Z","updated":"2019-07-16T04:34:22.717Z","comments":true,"path":"books/index.html","permalink":"https://markcai520.github.io/books/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-16T04:11:55.000Z","updated":"2019-07-16T04:11:55.560Z","comments":true,"path":"friends/index.html","permalink":"https://markcai520.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"最大间隙问题","slug":"Maxgap","date":"2019-07-15T11:18:30.000Z","updated":"2019-07-16T07:47:34.738Z","comments":true,"path":"2019/07/15/Maxgap/","link":"","permalink":"https://markcai520.github.io/2019/07/15/Maxgap/","excerpt":"最大间隙问题问题描述： 给定n个实数x1,x2,…,xn,求这n个数在实轴相邻2个数之间的最大差值。假设对任何实数的下取整函数耗时O(1)，设计解最大间隙问题的线性时间算法。","text":"最大间隙问题问题描述： 给定n个实数x1,x2,…,xn,求这n个数在实轴相邻2个数之间的最大差值。假设对任何实数的下取整函数耗时O(1)，设计解最大间隙问题的线性时间算法。 算法设计： 对于给定的n个实数x1,x2,…,xn，计算他们的最大间隙。 数据输入 输入数据由文件名为input.txt的文本文件提供。文件的第一行有1个正整数n。接下来的接下来的1行中有n个实数x1,x2,…,xn。 输入文件示例 input.txt 5 2.3 3.1 7.5 1.5 6.3 结果输出 将找到的最大间隙输出 输出文件示例 output.txt 3.2 分析与解答： 用鸽舍原理设计最大间隙问题的线性时间算法如下。 123456789101112131415161718192021222324252627282930313233double maxgap(int n,double *x) &#123; double minx = x[mini(n,x)],maxx = x[maxi(n,x)]; /* 用n-2个等间距的点分割区间[minx,maxx],产生n-1个桶，每个桶i中用high[i]和low[i]分别存储分配给桶i的数中的最大数和最小数 */ int *count = new int[n+1]; double *low = new double[n+1]; double *high = new double[n+1]; //桶初始化 for (int i = 1; i &lt;= n - 1; i ++) &#123; count[i] = 0; low[i] = maxx; high[i] = minx; &#125; //将n个数置于n-1个桶中 for (int i = 1; i &lt;= n; i ++) &#123; int bucket = int((n-1) * (x[i] - minx) / (maxx - minx)) + 1; count[bucket] ++; if (x[i] &lt; low[bucket] &lt; low[bucket]) low[bucket] = x[i]; if (x[i] &gt; high[bucket]) high[bucket] = x[i]; &#125; /* 此时，除了maxx和minx外的n-2个数被置于n-1个桶中，由鸽舍原理可知，至少有一个桶是空的，这意味着最大间隙不会出现在同一个桶中的两个数之间，对每一个桶做一次线性扫描即可找出最大间隙 */ double tmp = 0,left = high[1]; for (int i = 2; i &lt;= n - 1; i ++) &#123; if (count[i]) &#123; double thisgap = low[i] - left; if (thisgap &gt; tmp) tmp = thisgap; left = high[i]; &#125; &#125; return tmp;&#125; 其中，mini和maxi分别计算数组中最小元素和最大元素的下标。 12345678910111213141516171819202122template&lt;class T&gt;int mini(int n,T *x) &#123; T = tmp = x[1]; for (int i = 1,k = 1; i &lt;= n; i ++) &#123; if (x[i] &lt; tmp) &#123; tmp = x[i]; k = i; &#125; &#125; return k;&#125;template&lt;class T&gt;int maxi(int n,T *x) &#123; T tmp = x[1]; for (int i = 1,k = 1; i &lt;= n; i ++) &#123; if (x[i] &gt; tmp) &#123; tmp = x[i]; k = i; &#125; &#125; return k;&#125; 由于下取整函数耗时O(1)，故循环体内的运算耗时O(1)。因此，整个算法耗时O(n)。即算法maxgap是求最大间隙问题的线性时间算法。注意到在代数判定树计算模型下，Ω(nlogn)是最大间隙问题的一个计算时间下界。这意味着在代数判定树的计算模型下，最大间隙问题是不可能有线性时间算法的。在此题中假设下取整函数耗时O(1)，实际上这可以看作是在代数判定树模型中，将下取整运算作为基本运算增加到原有的基本运算集中，从而使代数判定树计算模型的计算能力得到增强。因而可以在线性时间内解最大间隙问题。","categories":[],"tags":[]}]}