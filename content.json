{"meta":{"title":"Mark's Inn","subtitle":null,"description":null,"author":"Mr.Cai","url":"https://markcai520.github.io","root":"/"},"pages":[{"title":"关于小站","date":"2019-07-16T04:13:45.000Z","updated":"2019-07-16T12:43:06.683Z","comments":true,"path":"about/index.html","permalink":"https://markcai520.github.io/about/index.html","excerpt":"匣有剑否，转身皆是江湖 剑未佩妥，出门便已是江湖 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初离学堂，踏入“江湖”，总归是要尝过千种心酸、万般无奈。在时间无情打磨之后，你总能得到一些东西。可人真的是“分三六九等”的，有的人初入职场，不多时，便游刃有余，升职加薪，不在话下，而有的人，勉强找个小工作，朝九晚六地干着，无论过多久，都是那个样子。这是为何？其实不难解释，同样是初入江湖，人家宝剑傍身，自信沉着，你赤手空拳，卑微怯懦，如何能比？","text":"匣有剑否，转身皆是江湖 剑未佩妥，出门便已是江湖 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初离学堂，踏入“江湖”，总归是要尝过千种心酸、万般无奈。在时间无情打磨之后，你总能得到一些东西。可人真的是“分三六九等”的，有的人初入职场，不多时，便游刃有余，升职加薪，不在话下，而有的人，勉强找个小工作，朝九晚六地干着，无论过多久，都是那个样子。这是为何？其实不难解释，同样是初入江湖，人家宝剑傍身，自信沉着，你赤手空拳，卑微怯懦，如何能比？ 愿你有利剑藏匣 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;职场是残酷的江湖，当然，所谓祸福相依，这里同样是你发家致富，走上人生巅峰的试炼场，只希望你心中有谱，手中有剑，所过之处，披荆斩棘。 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;咳咳，自从学了计算机，书读得相对以前少了许多，还是好好说人话算了，哈哈(^▽^) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博主目前是一个即将本科毕业的计算机专业小白，嘿嘿，真的，说起小白，我可是专业的哟~~，在这里想对和我一样即将毕业的同学，或是学弟学妹们说，当然，不打算从事计算机相关职业的出门左转(你要是开心，留下来也可以，哈哈哈)。无论你是打算考研，还是毕业直接进入职场，有几项技能都是你必须掌握的：操作系统、数据结构、算法(远不止这些，但这三个是我目前认为，相对来说最重要的三块，个人观点，欢迎来辩)。这里就不展开话题继续深聊了，有空再专门写两篇博客聊聊这三块怎么学吧。 联系博主 QQ：250057558 Email:18468126183@163.com 微信： 扫描下方二维码 &lt;图片给你搞大点，扫起来就方便啦&gt;"},{"title":"我的朋友","date":"2019-07-16T04:11:55.000Z","updated":"2019-07-16T12:36:46.622Z","comments":true,"path":"friends/index.html","permalink":"https://markcai520.github.io/friends/index.html","excerpt":"","text":"周耀宗简介 大学同学，前端高手 传送门"},{"title":"books","date":"2019-07-16T04:34:22.000Z","updated":"2019-07-16T04:34:22.717Z","comments":true,"path":"books/index.html","permalink":"https://markcai520.github.io/books/index.html","excerpt":"","text":""}],"posts":[{"title":"One algorithm question per day","slug":"algorithm","date":"2019-07-16T14:41:39.000Z","updated":"2019-07-16T15:49:21.052Z","comments":true,"path":"2019/07/16/algorithm/","link":"","permalink":"https://markcai520.github.io/2019/07/16/algorithm/","excerpt":"Introduction This blog is mainly used to record the process of learning algorithms in depth. The main programming languages are C, C++, Java, welcome to communicate actively, and my contact information on the right.","text":"Introduction This blog is mainly used to record the process of learning algorithms in depth. The main programming languages are C, C++, Java, welcome to communicate actively, and my contact information on the right. 1. 递归、分治1.1 字典序问题1.1.1 问题描述 在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表A由26个小写字母组成A={a,b,…,z}。该字母表产生的升序字符串是指字符串中字母从左到右出现的次序与字母在字母表中出现的次序相同，且每个字符最多出现1次。例如，a,b,ab,bc,xyz等字符串都是升序字符串。现在对字母表A产生的所有长度不超过6的升序字符串按照字典序排列并编码如下。 1 2 … 26 27 28 … a b … z ab ac … 对于任意长度不超过6的升序字符串，迅速计算出它在上述字典中的编码。 1.1.2 数据输入 输入数据由文件名为input.txt的文本文件提供。文件的第1行是一个正整数k，表示接下来有k行。在接下来的k行中，每行给出一个字符串。 输入文件示例 input.txt 2 a b 1.1.3 数据输出 将计算结果输出到文件output.txt中。文件共有k行，每行对应于一个字符串的编码。 输出文件示例 output.txt 1 2 1.1.4 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 public class DictionarySequence &#123; public static void main(String [] args) throws Exception &#123; BufferedReader br = new BufferedReader(new FileReader(\"dictionary_input.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"dictionary_output.txt\")); int count = Integer.parseInt(br.readLine()); //获取文件首行提供的行数 String str = \"\"; char [] s = &#123;&#125;; for (int row = 1; row &lt;= count; row ++) &#123; int sum = 0; str = br.readLine(); s = str.toCharArray(); if (s.length &gt; 6) &#123; bw.write(str + \" 的长度大于6，在此不进行字典序编码。\"); bw.newLine(); continue; &#125; /*统计长度小于str的长度的升序字符串个数*/ for (int i = 1; i &lt; s.length; i ++) sum += count_allk(i); int h = s[0] - 'a' + 1; //获取s中第一个字母 /*统计所有首字母小于s首字母的升序字符串个数*/ for(int i = 1; i &lt; h; i ++) sum += count_iandk(i,s.length); for (int i = 1,temp = h; i &lt; s.length; i ++) &#123; int n = s[i] - 'a' + 1; int length = s.length - i; //获取此时的长度 for(int j = temp + 1; j &lt; n; j ++) sum += count_iandk(j,length); temp = n; &#125; bw.write(str + \"-----&gt;\" + (sum + 1)); bw.newLine(); &#125; br.close(); bw.close(); &#125; /** * * @param i :字符串以第i个字符开头 * @param k :字符串长度为k * @return 以i开头长度为k的升序字符串的个数 */ public static int count_iandk(int i,int k) &#123; int sum = 0; if (k == 1) return 1; for(int j = i + 1; j &lt;= 26; j ++) sum += count_iandk(j,k - 1); return sum; &#125; /** * * @param k 字符串长度为k * @return 长度为k的升序字符串的个数 */ public static int count_allk (int k) &#123; int sum = 0; for (int i = 1; i &lt;= 26; i ++) &#123; sum += count_iandk(i,k); &#125; return sum; &#125;&#125; 1.1.5 运行结果 输入文件 输出文件 2. 贪心算法3. 动态规划4. 回溯法5. 分支限界法6. 随机化算法7. 线性规划与网络流","categories":[],"tags":[]},{"title":"Spring学习笔记<持续更新中>","slug":"spring","date":"2019-07-16T13:04:49.000Z","updated":"2019-07-16T14:15:53.810Z","comments":true,"path":"2019/07/16/spring/","link":"","permalink":"https://markcai520.github.io/2019/07/16/spring/","excerpt":"1. Spring学习路线 1. Spring的概述、Spring IOC(xml)、Spring的Bean管理、Spring属性注入2. Spring IOC的注解方式、Spring AOP(xml)3. Spring AOP的注解开发、Spring事务、JdbcTemplate","text":"1. Spring学习路线 1. Spring的概述、Spring IOC(xml)、Spring的Bean管理、Spring属性注入2. Spring IOC的注解方式、Spring AOP(xml)3. Spring AOP的注解开发、Spring事务、JdbcTemplate 1.1. Spring的概述1.1.1. 什么是Spring 先来看看百度百科给出的解释 简单总结一下 Spring:SE/EE开发的一站式框架 Spring具有EE开发的每一层的解决方案 &emsp;&emsp;Web层：SpringMVC &emsp;&emsp;Service层：Spring的Bean管理、Spring的事务 &emsp;&emsp;Dao层：Spring的Jdbc模板、Spring的ORM模块 1.1.2. Spring的优点 Java EE更加容易使用 面向对象的设计比任何实现技术(比如Java EE)都重要 面向接口编程，而不是针对类编程。Spring将使用接口的复杂度降低到零。（面向接口编程有哪些复杂度？） 代码应该易于测试。Spring框架会帮助你，使代码的测试更加简单 JavaBean提供了应用程序配置的最好方法 在Java中，已检查异常（Checked exception）被过度使用。框架不应该迫使你捕获不能恢复的异常 1.2. Spring IOC(xml)1.2.1. 什么是IOC? IOC:Inversion of control 控制反转 简单来说，就是将对象的创建权“反转”给Spring，即让Spring进行对象(也就是Bean)的管理 1.2.2. IOC的底层原理简介","categories":[],"tags":[]},{"title":"最大间隙问题","slug":"Maxgap","date":"2019-07-15T11:18:30.000Z","updated":"2019-07-16T07:47:34.738Z","comments":true,"path":"2019/07/15/Maxgap/","link":"","permalink":"https://markcai520.github.io/2019/07/15/Maxgap/","excerpt":"最大间隙问题问题描述： 给定n个实数x1,x2,…,xn,求这n个数在实轴相邻2个数之间的最大差值。假设对任何实数的下取整函数耗时O(1)，设计解最大间隙问题的线性时间算法。","text":"最大间隙问题问题描述： 给定n个实数x1,x2,…,xn,求这n个数在实轴相邻2个数之间的最大差值。假设对任何实数的下取整函数耗时O(1)，设计解最大间隙问题的线性时间算法。 算法设计： 对于给定的n个实数x1,x2,…,xn，计算他们的最大间隙。 数据输入 输入数据由文件名为input.txt的文本文件提供。文件的第一行有1个正整数n。接下来的接下来的1行中有n个实数x1,x2,…,xn。 输入文件示例 input.txt 5 2.3 3.1 7.5 1.5 6.3 结果输出 将找到的最大间隙输出 输出文件示例 output.txt 3.2 分析与解答： 用鸽舍原理设计最大间隙问题的线性时间算法如下。 123456789101112131415161718192021222324252627282930313233double maxgap(int n,double *x) &#123; double minx = x[mini(n,x)],maxx = x[maxi(n,x)]; /* 用n-2个等间距的点分割区间[minx,maxx],产生n-1个桶，每个桶i中用high[i]和low[i]分别存储分配给桶i的数中的最大数和最小数 */ int *count = new int[n+1]; double *low = new double[n+1]; double *high = new double[n+1]; //桶初始化 for (int i = 1; i &lt;= n - 1; i ++) &#123; count[i] = 0; low[i] = maxx; high[i] = minx; &#125; //将n个数置于n-1个桶中 for (int i = 1; i &lt;= n; i ++) &#123; int bucket = int((n-1) * (x[i] - minx) / (maxx - minx)) + 1; count[bucket] ++; if (x[i] &lt; low[bucket] &lt; low[bucket]) low[bucket] = x[i]; if (x[i] &gt; high[bucket]) high[bucket] = x[i]; &#125; /* 此时，除了maxx和minx外的n-2个数被置于n-1个桶中，由鸽舍原理可知，至少有一个桶是空的，这意味着最大间隙不会出现在同一个桶中的两个数之间，对每一个桶做一次线性扫描即可找出最大间隙 */ double tmp = 0,left = high[1]; for (int i = 2; i &lt;= n - 1; i ++) &#123; if (count[i]) &#123; double thisgap = low[i] - left; if (thisgap &gt; tmp) tmp = thisgap; left = high[i]; &#125; &#125; return tmp;&#125; 其中，mini和maxi分别计算数组中最小元素和最大元素的下标。 12345678910111213141516171819202122template&lt;class T&gt;int mini(int n,T *x) &#123; T = tmp = x[1]; for (int i = 1,k = 1; i &lt;= n; i ++) &#123; if (x[i] &lt; tmp) &#123; tmp = x[i]; k = i; &#125; &#125; return k;&#125;template&lt;class T&gt;int maxi(int n,T *x) &#123; T tmp = x[1]; for (int i = 1,k = 1; i &lt;= n; i ++) &#123; if (x[i] &gt; tmp) &#123; tmp = x[i]; k = i; &#125; &#125; return k;&#125; 由于下取整函数耗时O(1)，故循环体内的运算耗时O(1)。因此，整个算法耗时O(n)。即算法maxgap是求最大间隙问题的线性时间算法。注意到在代数判定树计算模型下，Ω(nlogn)是最大间隙问题的一个计算时间下界。这意味着在代数判定树的计算模型下，最大间隙问题是不可能有线性时间算法的。在此题中假设下取整函数耗时O(1)，实际上这可以看作是在代数判定树模型中，将下取整运算作为基本运算增加到原有的基本运算集中，从而使代数判定树计算模型的计算能力得到增强。因而可以在线性时间内解最大间隙问题。","categories":[],"tags":[]}]}