{"meta":{"title":"Mark's Inn","subtitle":null,"description":null,"author":"Mr.Cai","url":"https://markcai520.github.io","root":"/"},"pages":[{"title":"我的朋友","date":"2019-07-16T04:11:55.000Z","updated":"2019-07-16T12:36:46.622Z","comments":true,"path":"friends/index.html","permalink":"https://markcai520.github.io/friends/index.html","excerpt":"","text":"周耀宗简介 大学同学，前端高手 传送门"},{"title":"books","date":"2019-07-16T04:34:22.000Z","updated":"2019-07-16T04:34:22.717Z","comments":true,"path":"books/index.html","permalink":"https://markcai520.github.io/books/index.html","excerpt":"","text":""},{"title":"关于小站","date":"2019-07-16T04:13:45.000Z","updated":"2019-07-16T12:43:06.683Z","comments":true,"path":"about/index.html","permalink":"https://markcai520.github.io/about/index.html","excerpt":"匣有剑否，转身皆是江湖 剑未佩妥，出门便已是江湖 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初离学堂，踏入“江湖”，总归是要尝过千种心酸、万般无奈。在时间无情打磨之后，你总能得到一些东西。可人真的是“分三六九等”的，有的人初入职场，不多时，便游刃有余，升职加薪，不在话下，而有的人，勉强找个小工作，朝九晚六地干着，无论过多久，都是那个样子。这是为何？其实不难解释，同样是初入江湖，人家宝剑傍身，自信沉着，你赤手空拳，卑微怯懦，如何能比？","text":"匣有剑否，转身皆是江湖 剑未佩妥，出门便已是江湖 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初离学堂，踏入“江湖”，总归是要尝过千种心酸、万般无奈。在时间无情打磨之后，你总能得到一些东西。可人真的是“分三六九等”的，有的人初入职场，不多时，便游刃有余，升职加薪，不在话下，而有的人，勉强找个小工作，朝九晚六地干着，无论过多久，都是那个样子。这是为何？其实不难解释，同样是初入江湖，人家宝剑傍身，自信沉着，你赤手空拳，卑微怯懦，如何能比？ 愿你有利剑藏匣 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;职场是残酷的江湖，当然，所谓祸福相依，这里同样是你发家致富，走上人生巅峰的试炼场，只希望你心中有谱，手中有剑，所过之处，披荆斩棘。 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;咳咳，自从学了计算机，书读得相对以前少了许多，还是好好说人话算了，哈哈(^▽^) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博主目前是一个即将本科毕业的计算机专业小白，嘿嘿，真的，说起小白，我可是专业的哟~~，在这里想对和我一样即将毕业的同学，或是学弟学妹们说，当然，不打算从事计算机相关职业的出门左转(你要是开心，留下来也可以，哈哈哈)。无论你是打算考研，还是毕业直接进入职场，有几项技能都是你必须掌握的：操作系统、数据结构、算法(远不止这些，但这三个是我目前认为，相对来说最重要的三块，个人观点，欢迎来辩)。这里就不展开话题继续深聊了，有空再专门写两篇博客聊聊这三块怎么学吧。 联系博主 QQ：250057558 Email:18468126183@163.com 微信： 扫描下方二维码 &lt;图片给你搞大点，扫起来就方便啦&gt;"}],"posts":[{"title":"Mybatis学习笔记","slug":"mybatis","date":"2019-07-19T00:45:37.000Z","updated":"2019-07-20T15:22:21.554Z","comments":true,"path":"2019/07/19/mybatis/","link":"","permalink":"https://markcai520.github.io/2019/07/19/mybatis/","excerpt":"mybatis学习路线 1.mybatis入门2.mybatis的深入和多表3.mybaits的缓存和注解开发","text":"mybatis学习路线 1.mybatis入门2.mybatis的深入和多表3.mybaits的缓存和注解开发 1.1. mybatis入门1.1.1. 什么是框架？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;框架是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题。使用框架的好处：框架封装了很多的细节，使开发者可以使用极简的方式实现功能。大大提高开发效率。 1.1.2. 三层架构 表现层：是用于展示数据的 业务层：是处理业务需求 持久层：是和数据库交互的 1.1.3. 持久层技术解决方案 JDBC技术：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreparedStatement&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResultSetSpring的JdbcTemplate：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring中对jdbc的简单封装Apache的DBUtils：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装 以上这些都不是框架&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDBC是规范&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring的JdbcTemplate和Apache的DBUtils都只是工具类 1.1.4. mybatis的概述 mybatis是一个用java编写的持久层框架。它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程它使用了ORM思想实现了结果集的封装。ORM：Object Relational Mappging 对象关系映射简单的说：就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。 数据表 实体类 user User id userId user_name userName 1.1.5. mybatis的入门 mybatis的环境搭建 第一步：创建maven工程并导入坐标 第二步：创建实体类和dao的接口 第三步：创建Mybatis的主配置文件 SqlMapConifg.xml 第四步：创建映射配置文件 UserDao.xml 环境搭建的注意事项： 第一个：创建UserDao.xml 和 UserDao.java时名称是为了和我们之前的知识保持一致。 在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper 所以：UserDao 和 UserMapper是一样的 第二个：在idea中创建目录的时候，它和包是不一样的 包在创建时：com.cwg.dao它是三级结构 目录在创建时：com.cwg.dao是一级目录 第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同 第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名 当我们遵从了第三，四，五点之后，我们在开发中就无须再写dao的实现类。 mybatis的入门案例 第一步：读取配置文件 第二步：创建SqlSessionFactory工厂 第三步：创建SqlSession 第四步：创建Dao接口的代理对象 第五步：执行dao中的方法 第六步：释放资源 注意事项： 不要忘记在映射配置中告知mybatis要封装到哪个实体类中 配置的方式：指定实体类的全限定类名 mybatis基于注解的入门案例： 把UserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句 同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。 明确： 我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。 不管使用XML还是注解配置。 但是Mybatis它是支持写dao实现类的。 1.1.6. 代码示例 maven坐标 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.cwg&lt;/groupId&gt; &lt;artifactId&gt;mybatis01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; sql脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT '用户名称', `birthday` datetime default NULL COMMENT '生日', `sex` char(1) default NULL COMMENT '性别', `address` varchar(256) default NULL COMMENT '地址', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user`(`username`,`birthday`,`sex`,`address`) values ('张三',null,'男','北京'),('李妍',null,'女','上海'),('小二王','2018-03-04 11:34:34','女','北京金燕龙'),('赵子龙',null,'男','深圳'),('老王','2018-03-07 17:37:26','男','北京'),('马莉',null,'女','重庆');DROP TABLE IF EXISTS `account`;CREATE TABLE `account` ( `ID` int(11) NOT NULL COMMENT '编号', `UID` int(11) default NULL COMMENT '用户编号', `MONEY` double default NULL COMMENT '金额', PRIMARY KEY (`ID`), KEY `FK_Reference_8` (`UID`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `account`(`ID`,`UID`,`MONEY`) values (1,1,1000),(2,2,1000),(3,3,2000);DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `ID` int(11) NOT NULL COMMENT '编号', `ROLE_NAME` varchar(30) default NULL COMMENT '角色名称', `ROLE_DESC` varchar(60) default NULL COMMENT '角色描述', PRIMARY KEY (`ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,'院长','管理整个学院'),(2,'总裁','管理整个公司'),(3,'校长','管理整个学校');DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `UID` int(11) NOT NULL COMMENT '用户编号', `RID` int(11) NOT NULL COMMENT '角色编号', PRIMARY KEY (`UID`,`RID`), KEY `FK_Reference_10` (`RID`), CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`), CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user_role`(`UID`,`RID`) values (1,1),(2,1),(3,2); mybatis的核心配置文件sqlMapConfig.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境 --&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务类型 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源，也叫连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的四个基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8&amp;amp;useSSL=false\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"wqnmlgb\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定的映射文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/cwg/dao/UserDao.xml\" /&gt; &lt;/mappers&gt; &lt;!-- 使用注解方式 --&gt;&lt;!-- &lt;mappers&gt;--&gt;&lt;!-- &lt;mapper class=\"com.cwg.dao.UserDao\" /&gt;--&gt;&lt;!-- &lt;/mappers&gt;--&gt;&lt;/configuration&gt; UserDao接口与其相应的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.cwg.dao;import com.cwg.domain.User;import org.apache.ibatis.annotations.ResultMap;import org.apache.ibatis.annotations.Select;import java.util.List;/** * @Author MyLei * @Date 2019/7/18 * 用户的持久层接口 */public interface UserDao &#123; /** * 查询所有操作 * @return */ List&lt;User&gt; findAll (); /** * 根据传入参数条件查询 * @param user 查询的条件：user具体哪些值不为空并不确定 * @return */ List&lt;User&gt; findUserByCondition (User user); void saveUser(User user);&#125;----------------------------------------------------------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.cwg.dao.UserDao\"&gt; &lt;!-- 配置查询所有 --&gt; &lt;select id=\"findAll\" resultType=\"com.cwg.domain.User\"&gt; select * from user &lt;/select&gt; &lt;!-- 根据条件查询 --&gt; &lt;select id=\"findUserByCondition\" parameterType=\"com.cwg.domain.User\" resultType=\"com.cwg.domain.User\"&gt; select * from user &lt;where&gt; &lt;if test=\"username != null\"&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"sex != null\"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;insert id=\"saveUser\" parameterType=\"com.cwg.domain.User\"&gt; insert into user (id,username,sex,birthday) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;sex&#125;,#&#123;birthday&#125;) &lt;/insert&gt;&lt;/mapper&gt; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.cwg.test;import com.cwg.dao.UserDao;import com.cwg.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;/** * @Author MyLei * @Date 2019/7/18 */public class MybatisTest &#123; private InputStream in; private SqlSession session; private UserDao mapper; @Before public void init () throws Exception &#123; //1. 读取配置文件 in = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); //2. 创建SqlSessionFactory工厂 SqlSessionFactory sf = new SqlSessionFactoryBuilder().build(in); //3. 使用工厂生产一个SqlSession对象,此处参数为true代表事务自动提交 session = sf.openSession(true); //4. 使用SqlSession创建Dao接口的代理对象 mapper = session.getMapper(UserDao.class); &#125; @After public void destroy() throws Exception&#123;// session.commit(); // 释放资源 session.close(); in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll() throws Exception&#123; List&lt;User&gt; users = mapper.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试保存方法 */ @Test public void testSave () throws Exception&#123; User user = new User (); user.setSex(\"1\"); user.setUsername(\"龙智55\"); user.setBirthday(new Date()); user.setAddress(\"云南师范大学\"); mapper.saveUser(user); &#125; /** * 测试查询所有 */ @Test public void testFindCondition() throws Exception&#123; User u = new User();// u.setUsername(null); u.setUsername(\"蔡万刚\"); u.setSex(\"1\"); List&lt;User&gt; users = mapper.findUserByCondition(u); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125; 2. mybatis的深入和多表2.1. mybatis的相关概念123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 1、连接池： 我们在实际开发中都会使用连接池。 因为它可以减少我们获取连接所消耗的时间。2、mybatis中的连接池 mybatis连接池提供了3种方式的配置： 配置的位置： 主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。 type属性的取值： POOLED 采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现 UNPOOLED 采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想。 JNDI 采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。 注意：如果不是web或者maven的war工程，是不能使用的。 我们课程中使用的是tomcat服务器，采用连接池就是dbcp连接池。3、mybatis中的事务 什么是事务 事务的四大特性ACID 不考虑隔离性会产生的3个问题：脏读、幻读、不可重复度 解决办法：四种隔离级别 它是通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚 4、mybatis中的多表查询 表之间的关系有几种： 一对多 多对一 一对一 多对多 举例： 用户和订单就是一对多 订单和用户就是多对一 一个用户可以下多个订单 多个订单属于同一个用户 人和身份证号就是一对一 一个人只能有一个身份证号 一个身份证号只能属于一个人 老师和学生之间就是多对多 一个学生可以被多个老师教过 一个老师可以交多个学生 特例： 如果拿出每一个订单，他都只能属于一个用户。 所以Mybatis就把多对一看成了一对一。 mybatis中的多表查询： 示例：用户和账户 一个用户可以有多个账户 一个账户只能属于一个用户（多个账户也可以属于同一个用户） 步骤： 1、建立两张表：用户表，账户表 让用户表和账户表之间具备一对多的关系：需要使用外键在账户表中添加 2、建立两个实体类：用户实体类和账户实体类 让用户和账户的实体类能体现出来一对多的关系 3、建立两个配置文件 用户的配置文件 账户的配置文件 4、实现配置： 当我们查询用户时，可以同时得到用户下所包含的账户信息 当我们查询账户时，可以同时得到账户的所属用户信息 示例：用户和角色 一个用户可以有多个角色 一个角色可以赋予多个用户 步骤： 1、建立两张表：用户表，角色表 让用户表和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键，在中间表中是外键。 2、建立两个实体类：用户实体类和角色实体类 让用户和角色的实体类能体现出来多对多的关系 各自包含对方一个集合引用 3、建立两个配置文件 用户的配置文件 角色的配置文件 4、实现配置： 当我们查询用户时，可以同时得到用户所包含的角色信息 当我们查询角色时，可以同时得到角色的所赋予的用户信息 2.2. 代码示例 角色相关接口与配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.cwg.dao;import com.cwg.domain.Role;import java.util.List;/** * @Author MyLei * @Date 2019/7/18 */public interface RoleDao &#123; /** * 查询所有角色，同时给出所下属的所有用户信息 * @return */ List&lt;Role&gt; findAll ();&#125;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.cwg.dao.RoleDao\"&gt; &lt;!-- 定义role表的resultMap --&gt; &lt;resultMap id=\"roleMap\" type=\"Role\"&gt; &lt;id column=\"rid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"role_name\" property=\"roleName\"&gt;&lt;/result&gt; &lt;result column=\"role_desc\" property=\"roleDesc\"&gt;&lt;/result&gt; &lt;collection property=\"users\" ofType=\"User\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\" /&gt; &lt;result column=\"address\" property=\"address\" /&gt; &lt;result column=\"sex\" property=\"sex\" /&gt; &lt;result column=\"birthday\" property=\"birthday\" /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"roleMap\"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left join user_role ur on r.id = ur.rid left join user u on u.id = ur.rid &lt;/select&gt;&lt;/mapper&gt; 用户相关接口与配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.cwg.dao;import com.cwg.domain.User;import org.apache.ibatis.annotations.ResultMap;import org.apache.ibatis.annotations.Select;import java.util.List;/** * @Author MyLei * @Date 2019/7/18 * 用户的持久层接口 */public interface UserDao &#123; /** * 查询所有用户，同时获取到用户下所有账户的信息 * @return */ List&lt;User&gt; findAll (); /** * 根据传入参数条件查询 * @param id * @return */ List&lt;User&gt; findUserById (Integer id);&#125;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.cwg.dao.UserDao\"&gt; &lt;!-- 配置查询所有 --&gt; &lt;select id=\"findAll\" resultType=\"user\"&gt; select * from user u left join account a on u.id = a.uid &lt;/select&gt; &lt;select id=\"findUserById\" parameterType=\"Integer\" resultType=\"User\"&gt; select * from user where id = #&#123;va&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.cwg.test;import com.cwg.dao.UserDao;import com.cwg.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;/** * @Author MyLei * @Date 2019/7/18 */public class UserTest &#123; private InputStream in; private SqlSession session; private UserDao mapper; @Before public void init () throws Exception &#123; //1. 读取配置文件 in = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); //2. 创建SqlSessionFactory工厂 SqlSessionFactory sf = new SqlSessionFactoryBuilder().build(in); //3. 使用工厂生产一个SqlSession对象,此处参数为true代表事务自动提交 session = sf.openSession(true); //4. 使用SqlSession创建Dao接口的代理对象 mapper = session.getMapper(UserDao.class); &#125; @After public void destroy() throws Exception&#123;// session.commit(); // 释放资源 session.close(); in.close(); &#125; @Test public void testFindAll () &#123; List&lt;User&gt; users = mapper.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125;package com.cwg.test;import com.cwg.dao.RoleDao;import com.cwg.dao.RoleDao;import com.cwg.domain.Role;import com.cwg.domain.Role;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;/** * @Author MyLei * @Date 2019/7/18 */public class RoleTest &#123; private InputStream in; private SqlSession session; private RoleDao mapper; @Before public void init () throws Exception &#123; //1. 读取配置文件 in = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); //2. 创建SqlSessionFactory工厂 SqlSessionFactory sf = new SqlSessionFactoryBuilder().build(in); //3. 使用工厂生产一个SqlSession对象,此处参数为true代表事务自动提交 session = sf.openSession(true); //4. 使用SqlSession创建Dao接口的代理对象 mapper = session.getMapper(RoleDao.class); &#125; @After public void destroy() throws Exception&#123;// session.commit(); // 释放资源 session.close(); in.close(); &#125; @Test public void testFindAll () &#123; List&lt;Role&gt; roles = mapper.findAll(); for (Role role : roles) &#123; System.out.println(role); &#125; &#125;&#125; 3. mybaits的缓存和注解开发3.1. mybatis中的延迟加载123456789101112问题：在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候，要不要把关联的账户查出来？ 在查询账户的时候，要不要把关联的用户查出来？ 在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。 在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。什么是延迟加载 在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）什么是立即加载 不管用不用，只要一调用方法，马上发起查询。在对应的四种表关系中：一对多，多对一，一对一，多对多 一对多，多对多：通常情况下我们都是采用延迟加载。 多对一，一对一：通常情况下我们都是采用立即加载。 3.2. mybatis中的缓存1234567891011121314151617181920212223242526什么是缓存 存在于内存中的临时数据。 为什么使用缓存 减少和数据库的交互次数，提高执行效率。 什么样的数据能使用缓存，什么样的数据不能使用 适用于缓存： 经常查询并且不经常改变的。 数据的正确与否对最终结果影响不大的。 不适用于缓存： 经常改变的数据 数据的正确与否对最终结果影响很大的。 例如：商品的库存，银行的汇率，股市的牌价。 Mybatis中的一级缓存和二级缓存 一级缓存： 它指的是Mybatis中SqlSession对象的缓存。 当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。 该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中 查询是否有，有的话直接拿出来用。 当SqlSession对象消失时，mybatis的一级缓存也就消失了。 二级缓存: 它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。 二级缓存的使用步骤： 第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置） 第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置） 第三步：让当前的操作支持二级缓存（在select标签中配置） 3.3. mybatis中的注解开发 示例代码 mybatis核心配置文件sqlMapConfig.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 引入外部属性文件 --&gt; &lt;properties resource=\"jdbc.properties\"/&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.cwg.domain\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"mysql\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定带有注解的dao接口的所在位置 --&gt; &lt;mappers&gt; &lt;package name=\"com.cwg.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 用户持久层接口UserDao 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.cwg.dao;import com.cwg.domain.User;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;import java.util.List;/** * @Author MyLei * @Date 2019/7/18 */public interface UserDao &#123; /** * 查询所有用户 * @return * mybatis针对CRUD的注解一共有四个 * @Select、@Update、@Insert、@Delete */ @Select(\"select * from user\") List&lt;User&gt; findAll (); /** * 保存用户 * @param user 要保存的用户信息 */ @Insert(\"insert into user(username,address,sex,birthday) values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)\") void saveUser (User user); /** * 修改用户信息 * @param user */ @Update(\"update user set username = #&#123;username&#125;,address = #&#123;address&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125; where id = #&#123;id&#125;\") void updateUser (User user); /** * 通过id删除用户 * @param id */ @Delete(\"delete from user where id = #&#123;value&#125;\") void deleteUser (Integer id); /** * 通过id查找用户 * @param id * @return */ @Select(\"select * from user where id = #&#123;id&#125;\") User findUser (Integer id); /** * 模糊查询 * #&#123;&#125;:占位符 * @Select(\"select * from user where username like \\\"%\\\"#&#123;username&#125;\\\"%\\\"\") * $&#123;&#125;:字符串拼接 * @Select(\"select * from user where username like '%$&#123;value&#125;%'\") * @param username * @return * * */ @Select(\"select * from user where username like '%$&#123;value&#125;%'\") List&lt;User&gt; findLike (String username); /** * 统计查询用户总数 * @return */ @Select(\"select count(*) from user\") int findTotalUser ();&#125; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.cwg.test;import com.cwg.dao.UserDao;import com.cwg.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;/** * @Author MyLei * @Date 2019/7/18 */public class AnnotaionTest &#123; private InputStream in; private SqlSession session; private UserDao mapper; @Before public void init () throws Exception&#123; in = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sf = new SqlSessionFactoryBuilder().build(in); session = sf.openSession(); mapper = session.getMapper(UserDao.class); &#125; @After public void destroy () throws Exception&#123; session.commit(); session.close(); in.close(); &#125; @Test public void testSave () &#123; User user = new User(); user.setUsername(\"周耀宗\"); user.setSex(\"1\"); user.setAddress(\"E1-415\"); user.setBirthday(new Date()); mapper.saveUser(user); &#125; @Test public void testUpdate () &#123; User user = new User (); user.setId(30); user.setUsername(\"董文斌\"); user.setSex(\"2\"); user.setBirthday(new Date()); user.setAddress(\"E1-415\"); mapper.updateUser(user); &#125; @Test public void testDelete () &#123; Integer id = 26; mapper.deleteUser(id); &#125; @Test public void testFind () &#123; User user = mapper.findUser(31); System.out.println(user); &#125; @Test public void testLike () &#123; List&lt;User&gt; users = mapper.findLike(\"小\"); for (User user : users) &#123; System.out.println(user); &#125; &#125; @Test public void testTotal () &#123; System.out.println(mapper.findTotalUser()); &#125;&#125;","categories":[],"tags":[]},{"title":"One algorithm question per day","slug":"algorithm","date":"2019-07-16T14:41:39.000Z","updated":"2019-07-17T15:07:08.704Z","comments":true,"path":"2019/07/16/algorithm/","link":"","permalink":"https://markcai520.github.io/2019/07/16/algorithm/","excerpt":"Introduction This blog is mainly used to record the process of learning algorithms in depth. The main programming languages are C, C++, Java, welcome to communicate actively, and my contact information on the right.","text":"Introduction This blog is mainly used to record the process of learning algorithms in depth. The main programming languages are C, C++, Java, welcome to communicate actively, and my contact information on the right. 1. 递归、分治1.1 字典序问题 查看详情 1.1.1 问题描述 在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表A由26个小写字母组成A={a,b,…,z}。该字母表产生的升序字符串是指字符串中字母从左到右出现的次序与字母在字母表中出现的次序相同，且每个字符最多出现1次。例如，a,b,ab,bc,xyz等字符串都是升序字符串。现在对字母表A产生的所有长度不超过6的升序字符串按照字典序排列并编码如下。 1 2 … 26 27 28 … a b … z ab ac … 对于任意长度不超过6的升序字符串，迅速计算出它在上述字典中的编码。 1.1.2 数据输入 输入数据由文件名为input.txt的文本文件提供。文件的第1行是一个正整数k，表示接下来有k行。在接下来的k行中，每行给出一个字符串。 输入文件示例 input.txt 2 a b 1.1.3 数据输出 将计算结果输出到文件output.txt中。文件共有k行，每行对应于一个字符串的编码。 输出文件示例 output.txt 1 2 1.1.4 示例代码 查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 public class DictionarySequence &#123; public static void main(String [] args) throws Exception &#123; BufferedReader br = new BufferedReader(new FileReader(\"dictionary_input.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"dictionary_output.txt\")); int count = Integer.parseInt(br.readLine()); //获取文件首行提供的行数 String str = \"\"; char [] s = &#123;&#125;; for (int row = 1; row &lt;= count; row ++) &#123; int sum = 0; str = br.readLine(); s = str.toCharArray(); if (s.length &gt; 6) &#123; bw.write(str + \" 的长度大于6，在此不进行字典序编码。\"); bw.newLine(); continue; &#125; /*统计长度小于str的长度的升序字符串个数*/ for (int i = 1; i &lt; s.length; i ++) sum += count_allk(i); int h = s[0] - 'a' + 1; //获取s中第一个字母 /*统计所有首字母小于s首字母的升序字符串个数*/ for(int i = 1; i &lt; h; i ++) sum += count_iandk(i,s.length); for (int i = 1,temp = h; i &lt; s.length; i ++) &#123; int n = s[i] - 'a' + 1; int length = s.length - i; //获取此时的长度 for(int j = temp + 1; j &lt; n; j ++) sum += count_iandk(j,length); temp = n; &#125; bw.write(str + \"-----&gt;\" + (sum + 1)); bw.newLine(); &#125; br.close(); bw.close(); &#125; /** * * @param i :字符串以第i个字符开头 * @param k :字符串长度为k * @return 以i开头长度为k的升序字符串的个数 */ public static int count_iandk(int i,int k) &#123; int sum = 0; if (k == 1) return 1; for(int j = i + 1; j &lt;= 26; j ++) sum += count_iandk(j,k - 1); return sum; &#125; /** * * @param k 字符串长度为k * @return 长度为k的升序字符串的个数 */ public static int count_allk (int k) &#123; int sum = 0; for (int i = 1; i &lt;= 26; i ++) &#123; sum += count_iandk(i,k); &#125; return sum; &#125;&#125; 1.1.5 运行结果 输入文件 输出文件 2. 贪心算法2.1. 多元Huffman编码问题查看详情 2.1.1. 问题描述 在一个操场的四周摆放着n堆石子。现要将石子有次序地合并成一堆。规定每次至少选2堆最多选k堆石子合并成新的一堆，合并的费用为新的一堆石子的石子数。试设计一个算法，计算出将n堆石子合并成一堆的最大总费用和最小总费用。 2.1.2. 数据输入 输入数据由文件input.txt给出。文件的第1行有2个正整数n和k，表示有n对石子，每次至少选择2堆最多选择k堆石子合并。第2行有n个数，分别表示每堆石子的个数。输入文件示例input.txt7 345 13 12 16 9 5 22 2.1.3. 结果输出 将计算结果输出到文件output.txt中。输出文件示例output.txt593 199 2.1.4. 示例代码 查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * @Author MyLei * @Date 2019/7/17 */public class DuoyuanHuffman &#123; private static int n,k; private static int[] numbers; public static void main(String [] args) throws Exception &#123; BufferedReader br = new BufferedReader(new FileReader(\"E:\\\\IDEAProject\\\\algorithm\\\\src\\\\input.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"E:\\\\IDEAProject\\\\algorithm\\\\src\\\\output.txt\")); PriorityQueue&lt;Integer&gt; minQueue; PriorityQueue&lt;Integer&gt; maxQueue; String [] str = br.readLine().split(\" \"); n = Integer.parseInt(str[0]); k = Integer.parseInt(str[1]); numbers = new int[n+1]; //默认升序 minQueue = new PriorityQueue&lt;&gt;(n); //降序 maxQueue = new PriorityQueue&lt;&gt;(n, Comparator.reverseOrder()); str = br.readLine().split(\" \"); for(int i=1; i&lt;=n; i++)&#123; numbers[i] = Integer.parseInt(str[i - 1]); minQueue.add(numbers[i]); maxQueue.add(numbers[i]); &#125; int max = getMaxValueByQueue(maxQueue); int min = getMinValueByQueue(minQueue); bw.write(\"Max: \"+max); bw.newLine(); bw.write(\"Min: \"+min); br.close(); bw.close(); &#125; /** * 每次选k堆最小的，不足补0 * @param queue * @return 得出k堆中最小的 */ private static int getMinValueByQueue(PriorityQueue&lt;Integer&gt; queue)&#123; int i,j,m,t,sum,z; m = (k-n%(k-1))%(k-1); //补0 for(i=1,t=0; i&lt;=k-m; i++)&#123; t += queue.poll(); &#125; sum = t; z = (n-k+m)/(k-1); queue.add(t); for(i=1; i&lt;=z; i++)&#123; //每次选k堆最小的 for(j=1,t=0; j&lt;=k; j++) &#123; t += queue.poll(); &#125; sum += t; queue.add(t); &#125; return sum; &#125; /** * 每次选2堆最大的 * @param queue * @return 2堆最大的和 */ private static int getMaxValueByQueue(PriorityQueue&lt;Integer&gt; queue)&#123; int sum = 0,temp; for(int i=1; i&lt;=n-1; i++)&#123; temp = queue.poll() + queue.poll(); sum += temp; queue.add(temp); &#125; return sum; &#125;&#125; 2.1.5. 运行结果 输入文件 输出文件 3. 动态规划4. 回溯法5. 分支限界法6. 随机化算法7. 线性规划与网络流","categories":[],"tags":[]},{"title":"Spring学习笔记<持续更新中>","slug":"spring","date":"2019-07-16T13:04:49.000Z","updated":"2019-07-17T06:55:15.756Z","comments":true,"path":"2019/07/16/spring/","link":"","permalink":"https://markcai520.github.io/2019/07/16/spring/","excerpt":"1. Spring学习路线 1. Spring的概述、Spring IOC(xml)、Spring的Bean管理、Spring属性注入2. Spring IOC的注解方式、Spring AOP(xml)3. Spring AOP的注解开发、Spring事务、JdbcTemplate","text":"1. Spring学习路线 1. Spring的概述、Spring IOC(xml)、Spring的Bean管理、Spring属性注入2. Spring IOC的注解方式、Spring AOP(xml)3. Spring AOP的注解开发、Spring事务、JdbcTemplate 1.1. Spring的概述1.1.1. 什么是Spring 先来看看百度百科给出的解释 简单总结一下 Spring:SE/EE开发的一站式框架 Spring具有EE开发的每一层的解决方案 &emsp;&emsp;Web层：SpringMVC &emsp;&emsp;Service层：Spring的Bean管理、Spring的事务 &emsp;&emsp;Dao层：Spring的Jdbc模板、Spring的ORM模块 1.1.2. Spring的优点 Java EE更加容易使用 面向对象的设计比任何实现技术(比如Java EE)都重要 面向接口编程，而不是针对类编程。Spring将使用接口的复杂度降低到零。（面向接口编程有哪些复杂度？） 代码应该易于测试。Spring框架会帮助你，使代码的测试更加简单 JavaBean提供了应用程序配置的最好方法 在Java中，已检查异常（Checked exception）被过度使用。框架不应该迫使你捕获不能恢复的异常 1.2. Spring IOC(xml)1.2.1. 什么是IOC? IOC:Inversion of control 控制反转 简单来说，就是将对象的创建权“反转”给Spring，即让Spring进行对象(也就是Bean)的管理 1.2.2. IOC的底层原理简介","categories":[],"tags":[]},{"title":"最大间隙问题","slug":"Maxgap","date":"2019-07-15T11:18:30.000Z","updated":"2019-07-16T07:47:34.738Z","comments":true,"path":"2019/07/15/Maxgap/","link":"","permalink":"https://markcai520.github.io/2019/07/15/Maxgap/","excerpt":"最大间隙问题问题描述： 给定n个实数x1,x2,…,xn,求这n个数在实轴相邻2个数之间的最大差值。假设对任何实数的下取整函数耗时O(1)，设计解最大间隙问题的线性时间算法。","text":"最大间隙问题问题描述： 给定n个实数x1,x2,…,xn,求这n个数在实轴相邻2个数之间的最大差值。假设对任何实数的下取整函数耗时O(1)，设计解最大间隙问题的线性时间算法。 算法设计： 对于给定的n个实数x1,x2,…,xn，计算他们的最大间隙。 数据输入 输入数据由文件名为input.txt的文本文件提供。文件的第一行有1个正整数n。接下来的接下来的1行中有n个实数x1,x2,…,xn。 输入文件示例 input.txt 5 2.3 3.1 7.5 1.5 6.3 结果输出 将找到的最大间隙输出 输出文件示例 output.txt 3.2 分析与解答： 用鸽舍原理设计最大间隙问题的线性时间算法如下。 123456789101112131415161718192021222324252627282930313233double maxgap(int n,double *x) &#123; double minx = x[mini(n,x)],maxx = x[maxi(n,x)]; /* 用n-2个等间距的点分割区间[minx,maxx],产生n-1个桶，每个桶i中用high[i]和low[i]分别存储分配给桶i的数中的最大数和最小数 */ int *count = new int[n+1]; double *low = new double[n+1]; double *high = new double[n+1]; //桶初始化 for (int i = 1; i &lt;= n - 1; i ++) &#123; count[i] = 0; low[i] = maxx; high[i] = minx; &#125; //将n个数置于n-1个桶中 for (int i = 1; i &lt;= n; i ++) &#123; int bucket = int((n-1) * (x[i] - minx) / (maxx - minx)) + 1; count[bucket] ++; if (x[i] &lt; low[bucket] &lt; low[bucket]) low[bucket] = x[i]; if (x[i] &gt; high[bucket]) high[bucket] = x[i]; &#125; /* 此时，除了maxx和minx外的n-2个数被置于n-1个桶中，由鸽舍原理可知，至少有一个桶是空的，这意味着最大间隙不会出现在同一个桶中的两个数之间，对每一个桶做一次线性扫描即可找出最大间隙 */ double tmp = 0,left = high[1]; for (int i = 2; i &lt;= n - 1; i ++) &#123; if (count[i]) &#123; double thisgap = low[i] - left; if (thisgap &gt; tmp) tmp = thisgap; left = high[i]; &#125; &#125; return tmp;&#125; 其中，mini和maxi分别计算数组中最小元素和最大元素的下标。 12345678910111213141516171819202122template&lt;class T&gt;int mini(int n,T *x) &#123; T = tmp = x[1]; for (int i = 1,k = 1; i &lt;= n; i ++) &#123; if (x[i] &lt; tmp) &#123; tmp = x[i]; k = i; &#125; &#125; return k;&#125;template&lt;class T&gt;int maxi(int n,T *x) &#123; T tmp = x[1]; for (int i = 1,k = 1; i &lt;= n; i ++) &#123; if (x[i] &gt; tmp) &#123; tmp = x[i]; k = i; &#125; &#125; return k;&#125; 由于下取整函数耗时O(1)，故循环体内的运算耗时O(1)。因此，整个算法耗时O(n)。即算法maxgap是求最大间隙问题的线性时间算法。注意到在代数判定树计算模型下，Ω(nlogn)是最大间隙问题的一个计算时间下界。这意味着在代数判定树的计算模型下，最大间隙问题是不可能有线性时间算法的。在此题中假设下取整函数耗时O(1)，实际上这可以看作是在代数判定树模型中，将下取整运算作为基本运算增加到原有的基本运算集中，从而使代数判定树计算模型的计算能力得到增强。因而可以在线性时间内解最大间隙问题。","categories":[],"tags":[]}]}