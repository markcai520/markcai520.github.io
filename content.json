{"meta":{"title":"Mark's Blog","subtitle":null,"description":null,"author":"Mr.Cai","url":"https://markcai520.github.io","root":"/"},"pages":[{"title":"books","date":"2019-07-16T04:34:22.000Z","updated":"2019-07-16T04:34:22.717Z","comments":true,"path":"books/index.html","permalink":"https://markcai520.github.io/books/index.html","excerpt":"","text":""},{"title":"about","date":"2019-07-16T04:13:45.000Z","updated":"2019-07-16T04:13:45.804Z","comments":true,"path":"about/index.html","permalink":"https://markcai520.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-16T04:11:55.000Z","updated":"2019-07-16T04:11:55.560Z","comments":true,"path":"friends/index.html","permalink":"https://markcai520.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"最大间隙问题","slug":"Maxgap","date":"2019-07-15T11:18:30.000Z","updated":"2019-07-16T06:34:53.690Z","comments":true,"path":"2019/07/15/Maxgap/","link":"","permalink":"https://markcai520.github.io/2019/07/15/Maxgap/","excerpt":"最大间隙问题问题描述： 给定n个实数x1,x2,…,xn,求这n个数在实轴相邻2个数之间的最大差值。假设对任何实数的下取整函数耗时O(1)，设计解最大间隙问题的线性时间算法。","text":"最大间隙问题问题描述： 给定n个实数x1,x2,…,xn,求这n个数在实轴相邻2个数之间的最大差值。假设对任何实数的下取整函数耗时O(1)，设计解最大间隙问题的线性时间算法。 算法设计： 对于给定的n个实数x1,x2,…,xn，计算他们的最大间隙。 数据输入 输入数据由文件名为input.txt的文本文件提供。文件的第一行有1个正整数n。接下来的接下来的1行中有n个实数x1,x2,…,xn。 结果输出 将找到的最大间隙输出 输入文件示例 输出文件示例 input.txt output.txt 5 3.2 2.3 3.1 7.5 1.5 6.3 分析与解答： 用鸽舍原理设计最大间隙问题的线性时间算法如下。 123456789101112131415161718192021222324252627282930313233double maxgap(int n,double *x) &#123; double minx = x[mini(n,x)],maxx = x[maxi(n,x)]; /* 用n-2个等间距的点分割区间[minx,maxx],产生n-1个桶，每个桶i中用high[i]和low[i]分别存储分配给桶i的数中的最大数和最小数 */ int *count = new int[n+1]; double *low = new double[n+1]; double *high = new double[n+1]; //桶初始化 for (int i = 1; i &lt;= n - 1; i ++) &#123; count[i] = 0; low[i] = maxx; high[i] = minx; &#125; //将n个数置于n-1个桶中 for (int i = 1; i &lt;= n; i ++) &#123; int bucket = int((n-1) * (x[i] - minx) / (maxx - minx)) + 1; count[bucket] ++; if (x[i] &lt; low[bucket] &lt; low[bucket]) low[bucket] = x[i]; if (x[i] &gt; high[bucket]) high[bucket] = x[i]; &#125; /* 此时，除了maxx和minx外的n-2个数被置于n-1个桶中，由鸽舍原理可知，至少有一个桶是空的，这意味着最大间隙不会出现在同一个桶中的两个数之间，对每一个桶做一次线性扫描即可找出最大间隙 */ double tmp = 0,left = high[1]; for (int i = 2; i &lt;= n - 1; i ++) &#123; if (count[i]) &#123; double thisgap = low[i] - left; if (thisgap &gt; tmp) tmp = thisgap; left = high[i]; &#125; &#125; return tmp;&#125; 其中，mini和maxi分别计算数组中最小元素和最大元素的下标。 12345678910111213141516171819202122template&lt;class T&gt;int mini(int n,T *x) &#123; T = tmp = x[1]; for (int i = 1,k = 1; i &lt;= n; i ++) &#123; if (x[i] &lt; tmp) &#123; tmp = x[i]; k = i; &#125; &#125; return k;&#125;template&lt;class T&gt;int maxi(int n,T *x) &#123; T tmp = x[1]; for (int i = 1,k = 1; i &lt;= n; i ++) &#123; if (x[i] &gt; tmp) &#123; tmp = x[i]; k = i; &#125; &#125; return k;&#125; 由于下取整函数耗时O(1)，故循环体内的运算耗时O(1)。因此，整个算法耗时O(n)。即算法maxgap是求最大间隙问题的线性时间算法。注意到在代数判定树计算模型下，Ω(nlogn)是最大间隙问题的一个计算时间下界。这意味着在代数判定树的计算模型下，最大间隙问题是不可能有线性时间算法的。在此题中假设下取整函数耗时O(1)，实际上这可以看作是在代数判定树模型中，将下取整运算作为基本运算增加到原有的基本运算集中，从而使代数判定树计算模型的计算能力得到增强。因而可以在线性时间内解最大间隙问题。","categories":[],"tags":[]}]}